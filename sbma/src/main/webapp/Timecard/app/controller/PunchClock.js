/*
 * File: app/controller/PunchClock.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.0.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.0.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Timecard.controller.PunchClock', {
    extend: 'Ext.app.Controller',

    requires: [
        'Timecard.controller.IntervalTimer'
    ],

    config: {
        authenticationToken: 0,

        refs: {
            clock: '[xst=clock]',
            timeCardItemList: '[xst=timeCardItemList]',
            clockInButton: '[xst=clockIn]',
            clockOutButton: '[xst=clockOut]'
        },

        control: {
            "[xst=punchClockView]": {
                initialize: 'onContainerInitialize',
                remove: 'onContainerRemove',
                activate: 'onPunchClockViewActivate',
                loadcomplete: 'onContainerLoadcomplete'
            },
            "[xst=clockIn]": {
                tap: 'onClockInTap'
            },
            "[xst=clockOut]": {
                tap: 'onClockOutTap'
            },
            "[xst=logout]": {
                tap: 'onLogoutTap'
            }
        }
    },

    onContainerInitialize: function(component, options) {
        console.log("onPunchClockViewInitialize: entered");

        this.displayTime();
        this.intervalTimer.start();

    },

    onContainerRemove: function(container, item, index, options) {
        this.intervalTimer.stop();
    },

    onClockInTap: function(button, e, options) {
        var me = this;

        if (navigator && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                me.clockIn(position);
            }, function(error) {
                Ext.Msg.alert('Cannot Clock In', 'Geolocation not enabled');
            });
        } else {
            Ext.Msg.alert('Cannot Clock In', 'Geolocation not supported');
        }
    },

    onClockOutTap: function(button, e, options) {
        var me = this;

        if (navigator && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                me.validateClockOutRequest(position);
            }, function(error) {
                Ext.Msg.alert('Cannot Clock Out', 'Geolocation not enabled');
            });
        } else {
            Ext.Msg.alert('Cannot Clock Out', 'Geolocation not supported');
        }
    },

    onLogoutTap: function(button, e, options) {
        Timecard.controller.EventBus.fireLogoutEvent();
    },

    onPunchClockViewActivate: function(container, newActiveItem, oldActiveItem, options) {
        console.log("onPunchClockViewActivate: entered");
        var store = Ext.getStore("timeCardItem");
        var authenticationToken = this.getAuthenticationToken();
        store.loadTimeCardItems(authenticationToken);
    },

    onContainerLoadcomplete: function(store, eventOptions) {
        this.configureView(store);
    },

    init: function(application) {
        this.intervalTimer = Ext.create('Timecard.controller.IntervalTimer', {
            interval: 1000,
            fn: this.displayTime,
            fnScope: this
        });

        Timecard.controller.EventBus.addLoginListener(this.onLogin, this);

    },

    configureView: function(store) {
        var firstInProgressItem = this.findFirstInProgressItem(store);
        if (firstInProgressItem) {
            this.selectAndScroll(this.getTimeCardItemList(), firstInProgressItem);
            this.getClockInButton().disable();
            this.getClockOutButton().enable();
        } else {
            var lastCompletedItem = this.findLastCompletedItem(store);
            if (lastCompletedItem) {
                this.selectAndScroll(this.getTimeCardItemList(), lastCompletedItem);
            }
            this.getClockInButton().enable();
            this.getClockOutButton().disable();
        }
    },

    findFirstInProgressItem: function(store) {
        var firstInProgressItem = null;

        store.each(function (record) {
            if (record.get('type') == Timecard.model.Constants.IN_PROGRESS) {
                firstInProgressItem = record;
                return false;
            }
            return true;
        }, this);

        return firstInProgressItem;
    },

    findLastCompletedItem: function(store) {
        var lastCompletedItem = null;

        store.each(function (record) {
            if (record.get('type') == Timecard.model.Constants.COMPLETED) {
                lastCompletedItem = record;
            }
            return true;
        }, this);

        return lastCompletedItem;
    },

    displayTime: function() {
        var date = new Date();
        var formattedTime = Ext.Date.format(date, 'H:i:s');
        var formattedDate = Ext.Date.format(date, 'm/d/Y');
        var formattedClock = formattedTime + ' on ' + formattedDate;
        this.getClock().setTitle(formattedClock);
    },

    clockIn: function(position) {
        var url = '/sbma/rest/timeCardItem?&at=' + this.getAuthenticationToken();

        var date = Ext.util.Format.date(new Date(), 'c');

        Ext.Ajax.request({
            method: 'POST',
            url: url,
            timeout: 60000,
            jsonData: {
                id: -1,
                type: Timecard.model.Constants.IN_PROGRESS,
                beginDate: date,
                endDate: null,
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
            },
            scope: this,
            success: this.onClockInCallback,
            failure: function() {
                Ext.Msg.alert("Clock In", "Cannot communicate with server");
            }
        });

    },

    validateClockOutRequest: function(position) {
        var me = this;

        var store = Ext.data.StoreManager.lookup('timeCardItem');

        var item = this.findFirstInProgressItem(store);

        if (item) {

            var from = new google.maps.LatLng(item.get('latitude'), item.get('longitude'));
            var to = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
            dist = google.maps.geometry.spherical.computeDistanceBetween(from, to, Timecard.model.Constants.RADIUS);

            if (dist >= Timecard.model.Constants.CLOCK_OUT_LIMIT) {
                Ext.Msg.prompt('Explanation Required', 'Clock out location exceeds allowed distance from clock in.', function(button, text) {
                    me.clockOut(item, text);
                });
            } else {
                me.clockOut(item);
            }
        }

    },

    clockOut: function(item, notes) {
        // With the SBMA Timecard application, the clock in time, clock out time and
        // geolocation are reported by the client. The employee gets paid based on hours
        // worked, and the clock out location must be within a configurable distance from
        // the clock in location to ensure the employee didn't go home early and clock out.
        // This client reporting of financially valuable information would not be allowed
        // in some industries (e.g. banking) because of the ease with which it could be
        // spoofed. We're assuming this is not an issue for our Timecard example. 

        var url = '/sbma/rest/timeCardItem?&at=' + this.getAuthenticationToken();

        var beginDate = Ext.util.Format.date(item.get('beginDate'), 'c');
        var endDate = Ext.util.Format.date(new Date(), 'c');

        Ext.Ajax.request({
            method: 'POST',
            url: url,
            timeout: 60000,
            jsonData: {
                id: item.get('id'),
                type: Timecard.model.Constants.COMPLETED,
                beginDate: beginDate,
                endDate: endDate,
                notes: notes
            },
            scope: this,
            success: this.onClockOutCallback,
            failure: function() {
                Ext.Msg.alert("Clock In", "Cannot communicate with server");
            }
        });

    },

    onClockInCallback: function(response) {
        var timeCardItemDto = Ext.decode(response.responseText);
        var timeCardItemModel = Ext.create('Timecard.model.TimeCardItem', timeCardItemDto);
        var store = Ext.data.StoreManager.lookup('timeCardItem');
        store.add(timeCardItemModel);
        this.configureView(store);
    },

    onClockOutCallback: function(response) {
        var timeCardItemDto = Ext.decode(response.responseText);
        var store = Ext.data.StoreManager.lookup('timeCardItem');
        var index = store.find('id', timeCardItemDto.id);
        var model = store.getAt(index);
        // It appears that setData does not result in List updating its display
        //model.setData(timeCardItemDto);
        model.set('type', timeCardItemDto.type);
        model.set('endDate', timeCardItemDto.endDate);
        this.configureView(store);
    },

    onLogin: function(credentialResponseModel) {
        this.setAuthenticationToken(credentialResponseModel.get('authenticationToken'));
    },

    selectAndScroll: function(list, record) {
        list.select(record);
        var store = list.getStore();
        var index = store.indexOf(record);
        var items = list.container.getViewItems();
        var element = items[index];
        var offset = Ext.get(element).dom.offsetTop;
        // TODO: Need to be smart about how we scroll so that some context is visible
        list.getScrollable().getScroller().scrollTo(0, offset);

    }

});